From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Spottedleaf <spottedleaf@spottedleaf.dev>
Date: Sat, 4 Apr 2020 15:27:44 -0700
Subject: [PATCH] Allow controlled flushing for network manager

Only make one flush call when emptying the packet queue too

This patch will be used to optimise out flush calls in later
patches.

diff --git a/src/main/java/net/minecraft/server/NetworkManager.java b/src/main/java/net/minecraft/server/NetworkManager.java
index 211a6d7206788cbac80f2117d106f39ac3ef6dd5..9bcd6c75bee67d7d42c562ebbe99608d2cbe2614 100644
--- a/src/main/java/net/minecraft/server/NetworkManager.java
+++ b/src/main/java/net/minecraft/server/NetworkManager.java
@@ -175,6 +175,11 @@ public class NetworkManager extends SimpleChannelInboundHandler<Packet<?>> {
 
     private void dispatchPacket(Packet<?> packet, @Nullable GenericFutureListener<? extends Future<? super Void>> genericFutureListener) { this.b(packet, genericFutureListener); } // Paper - OBFHELPER
     private void b(Packet<?> packet, @Nullable GenericFutureListener<? extends Future<? super Void>> genericfuturelistener) {
+        // Tuinity start - add flush parameter
+        this.writePacket(packet, genericfuturelistener, true);
+    }
+    private final void writePacket(Packet<?> packet, @Nullable GenericFutureListener<? extends Future<? super Void>> genericfuturelistener, boolean flush) {
+        // Tuinity end - add flush parameter
         EnumProtocol enumprotocol = EnumProtocol.a(packet);
         EnumProtocol enumprotocol1 = (EnumProtocol) this.channel.attr(NetworkManager.c).get();
 
@@ -189,7 +194,7 @@ public class NetworkManager extends SimpleChannelInboundHandler<Packet<?>> {
                 this.setProtocol(enumprotocol);
             }
 
-            ChannelFuture channelfuture = this.channel.writeAndFlush(packet);
+            ChannelFuture channelfuture = (flush) ? this.channel.writeAndFlush(packet) : this.channel.write(packet); // Tuinity - add flush parameter
 
             if (genericfuturelistener != null) {
                 channelfuture.addListener(genericfuturelistener);
@@ -202,7 +207,7 @@ public class NetworkManager extends SimpleChannelInboundHandler<Packet<?>> {
                     this.setProtocol(enumprotocol);
                 }
 
-                ChannelFuture channelfuture1 = this.channel.writeAndFlush(packet);
+                ChannelFuture channelfuture1 = (flush) ? this.channel.writeAndFlush(packet) : this.channel.write(packet); // Tuinity - add flush parameter
 
                 if (genericfuturelistener != null) {
                     channelfuture1.addListener(genericfuturelistener);
@@ -216,16 +221,46 @@ public class NetworkManager extends SimpleChannelInboundHandler<Packet<?>> {
         java.util.List<Packet> extraPackets = packet.getExtraPackets();
         if (extraPackets != null && !extraPackets.isEmpty()) {
             for (Packet extraPacket : extraPackets) {
-                this.dispatchPacket(extraPacket, genericfuturelistener);
+                this.writePacket(extraPacket, genericfuturelistener, flush); // Tuinity - add flush parameter
             }
         }
         // Paper end
 
     }
 
+    // Tuinity start - only make one flush call per sendPacketQueue() call
+    volatile boolean canFlush = true;
+
+    void disableAutomaticFlush() {
+        this.canFlush = false;
+    }
+
+    void enableAutomaticFlush() {
+        this.canFlush = true;
+        this.sendPacketQueue(); // note: this must be after the canFlush write
+    }
+
+    private final void flush() {
+        if (this.canFlush) {
+            if (this.channel.eventLoop().inEventLoop()) {
+                this.channel.flush();
+            } else {
+                this.channel.eventLoop().execute(() -> {
+                    this.channel.flush();
+                });
+            }
+        }
+    }
+    // Tuinity end - only make one flush call per sendPacketQueue() call
+
     // Paper start - Async-Anti-Xray - Stop dispatching further packets and return false if the peeked packet is a chunk packet which is not ready
     private boolean sendPacketQueue() { return this.o(); } // OBFHELPER // void -> boolean
     private boolean o() { // void -> boolean
+        // Tuinity start - let packets build up for the following sendPacketQueue when canFlush is set to true
+        if (!this.canFlush) {
+            return false;
+        }
+        // Tuinity end - let packets build up for the following sendPacketQueue when canFlush is set to true
         if (this.channel != null && this.channel.isOpen()) {
             Queue queue = this.packetQueue;
 
@@ -238,10 +273,13 @@ public class NetworkManager extends SimpleChannelInboundHandler<Packet<?>> {
                             return false; // Return false if the peeked packet is a chunk packet which is not ready
                         } else {
                             this.getPacketQueue().poll(); // poll here
-                            this.dispatchPacket(networkmanager_queuedpacket.getPacket(), networkmanager_queuedpacket.getGenericFutureListener()); // dispatch the packet
+                            this.writePacket(networkmanager_queuedpacket.getPacket(), networkmanager_queuedpacket.getGenericFutureListener(), false); // dispatch the packet // Tuinity - only make one flush call per sendPacketQueue() call
                         }
                     }
                 }
+                // Tuinity start - only make one flush call per sendPacketQueue() call
+                this.flush();
+                // Tuinity end - only make one flush call per sendPacketQueue() call
 
             }
         }
